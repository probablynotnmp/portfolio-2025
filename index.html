<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Prathyush N M</title>
    <meta name="description" content="Prathyush's updates, projects, articles, and stuff.">
    <link rel="icon" type="image/x-icon" href="assets/favicon.ico">
    <script>
        (function () {
            if (sessionStorage.getItem('visitedHome')) {
                document.documentElement.classList.add('skip-intro');
            } else {
                sessionStorage.setItem('visitedHome', '1');
            }
        })();
    </script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        html, body { width: 100%; height: 100%; overflow-x: hidden; }
        html { background-color: #EBE8E1; }
        body {
            font-family: 'Times New Roman', Times, serif;
            color: #2c2c2c;
            min-height: 100vh;
            display: flex;
            align-items: center;
            justify-content: flex-start;
            padding: 4rem 2rem 2rem 18rem;
            transition: color 0.5s ease;
            background-color: transparent;
            position: relative;
        }
        body::before {
            content: "";
            position: fixed;
            inset: 0;
            z-index: -2;
            background: linear-gradient(135deg, #f5f3ef 0%, #EBE8E1 100%);
            background-repeat: no-repeat;
            background-size: cover;
        }
        html.dark-mode, html.dark-mode body { background-color: #1E1E1E; }
        body.dark-mode::before { background: #1E1E1E; }
        .container {
            max-width: 600px;
            opacity: 0;
            transform: translateY(30px);
            animation: fadeInUp 1s ease forwards;
            position: relative;
            z-index: 10;
        }
        @keyframes fadeInUp { to { opacity: 1; transform: translateY(0); } }
        h1 {
            font-size: 3rem;
            font-weight: 400;
            margin-bottom: 0.5rem;
            letter-spacing: -0.5px;
            animation: fadeInUp 1s ease 0.2s forwards;
            opacity: 0;
            font-family: 'Times New Roman', Times, serif;
            color: #1a1a1a;
        }
        .subtitle {
            font-size: 1.2rem;
            color: #4a4a4a;
            margin-bottom: 1.5rem;
            font-family: 'Times New Roman', Times, serif;
            animation: fadeInUp 1s ease 0.4s forwards;
            opacity: 0;
        }
        .company { color: #7c5ab8; text-decoration: none; transition: color 0.3s ease; }
        .company:hover { color: #7c5ab8; opacity: 0.7; }
        nav { margin-top: 0; margin-bottom: 1.5rem; }
        .nav-link {
            display: block;
            font-size: 1.2rem;
            color: #7c2eb8;
            text-decoration: none;
            margin: 1rem 0;
            position: relative;
            padding-left: 1.5rem;
            transition: all 0.3s ease;
            opacity: 0;
            transform: translateX(-20px);
            font-family: 'Times New Roman', Times, serif;
        }
        .nav-link:nth-child(1) { animation: slideInLeft 0.6s ease 0.6s forwards; }
        .nav-link:nth-child(2) { animation: slideInLeft 0.6s ease 0.7s forwards; }
        .nav-link:nth-child(3) { animation: slideInLeft 0.6s ease 0.8s forwards; }
        .nav-link:nth-child(4) { animation: slideInLeft 0.6s ease 0.9s forwards; }
        @keyframes slideInLeft { to { opacity: 1; transform: translateX(0); } }
        .nav-link::before { content: 'â†³'; position: absolute; left: 0; transition: transform 0.3s ease; }
        .nav-link:hover { padding-left: 2rem; color: #6c2eb8; }
        .nav-link:hover::before { transform: translateX(5px); }
        .social-links {
            margin-top: 2.5rem;
            display: flex;
            gap: 1.5rem;
            opacity: 0;
            animation: fadeInUp 1s ease 1.2s forwards;
        }
        .social-links a { color: #8b4bdb; text-decoration: none; font-size: 1.05rem; transition: all 0.3s ease; display: inline-block; }
        .social-links svg { width: 22px; height: 22px; }
        .social-links a:hover { color: #6c2eb8; transform: translateY(-3px); }
        .theme-toggle {
            position: fixed;
            bottom: 2rem;
            right: 2rem;
            width: 50px;
            height: 50px;
            border-radius: 50%;
            background: rgba(124, 90, 184, 0.1);
            border: none;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.5rem;
            transition: all 0.3s ease;
            opacity: 0;
            animation: fadeInUp 1s ease 1.4s forwards;
            color: #7c5ab8;
            z-index: 20;
        }
        .theme-toggle:hover { background: rgba(124, 90, 184, 0.2); transform: scale(1.1); }
        .theme-icon { transition: opacity 0.3s ease, transform 0.3s ease; }
        .theme-icon.hidden { opacity: 0; transform: scale(0.5); position: absolute; }
        body.dark-mode { color: #e8e8e8; }
        body.dark-mode .subtitle { color: #c0c0c0; }
        body.dark-mode h1 { color: #e8e8e8; }
        body.dark-mode .company { color: #7c5ab8; }
        body.dark-mode .nav-link { color: #7c5ab8; }
        body.dark-mode .social-links a { color: #7c5ab8; }
        body.dark-mode .theme-toggle { background: rgba(124, 90, 184, 0.15); color: #7c5ab8; }
        body.dark-mode .theme-toggle:hover { background: rgba(124, 90, 184, 0.25); }
        @media (max-width: 768px) {
            body { padding: 2rem 2rem 2rem 1rem; justify-content: flex-start; align-items: center; }
            .container { max-width: 100%; }
            h1 { font-size: 2.5rem; }
            .subtitle { font-size: 1.1rem; }
            .nav-link { font-size: 1.1rem; }
        }
        html.skip-intro .container, html.skip-intro h1, html.skip-intro .subtitle, html.skip-intro .nav-link, html.skip-intro .social-links, html.skip-intro .theme-toggle {
            animation: none !important;
            opacity: 1 !important;
            transform: none !important;
        }
        .stage-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -1;
            pointer-events: none;
            overflow: hidden;
        }
        .canvas-container {
            width: 100%;
            height: 100%;
            position: absolute;
            top: 0;
            left: 0;
        }
        canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }
        .loading-init, .controls, .menu, .help-modal {
            display: none !important;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Prathyush N M</h1>
        <p class="subtitle">Co-founder of <a href="#" class="company">Datum</a></p>
        <nav>
            <a href="about" class="nav-link">About</a>
            <a href="posts" class="nav-link">Posts</a>
            <a href="projects" class="nav-link">Projects</a>
            <a href="contact" class="nav-link">Contact</a>
        </nav>
        <div class="social-links">
            <a href="https://github.com/probablynotnmp" aria-label="GitHub">
                <svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor"><path d="M12 0c-6.626 0-12 5.373-12 12 0 5.302 3.438 9.8 8.207 11.387.599.111.793-.261.793-.577v-2.234c-3.338.726-4.033-1.416-4.033-1.416-.546-1.387-1.333-1.756-1.333-1.756-1.089-.745.083-.729.083-.729 1.205.084 1.839 1.237 1.839 1.237 1.07 1.834 2.807 1.304 3.492.997.107-.775.418-1.305.762-1.604-2.665-.305-5.467-1.334-5.467-5.931 0-1.311.469-2.381 1.236-3.221-.124-.303-.535-1.524.117-3.176 0 0 1.008-.322 3.301 1.23.957-.266 1.983-.399 3.003-.404 1.02.005 2.047.138 3.006.404 2.291-1.552 3.297-1.23 3.297-1.23.653 1.653.242 2.874.118 3.176.77.84 1.235 1.911 1.235 3.221 0 4.609-2.807 5.624-5.479 5.921.43.372.823 1.102.823 2.222v3.293c0 .319.192.694.801.576 4.765-1.589 8.199-6.086 8.199-11.386 0-6.627-5.373-12-12-12z"/></svg>
            </a>
            <a href="https://x.com/prathyushnm" aria-label="Twitter">
                <svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor"><path d="M18.244 2.25h3.308l-7.227 8.26 8.502 11.24H16.17l-5.214-6.817L4.99 21.75H1.68l7.73-8.835L1.254 2.25H8.08l4.713 6.231zm-1.161 17.52h1.833L7.084 4.126H5.117z"/></svg>
            </a>
            <a href="https://www.linkedin.com/in/prathyushnm" aria-label="LinkedIn">
                <svg width="18" height="18" viewBox="0 0 24 24" fill="currentColor"><path d="M20.5 2h-17A1.5 1.5 0 002 3.5v17A1.5 1.5 0 003.5 22h17a1.5 1.5 0 001.5-1.5v-17A1.5 1.5 0 0020.5 2zM8 19H5v-9h3zM6.5 8.25A1.75 1.75 0 118.3 6.5a1.78 1.78 0 01-1.8 1.75zM19 19h-3v-4.74c0-1.42-.6-1.93-1.38-1.93A1.74 1.74 0 0013 14.19a.66.66 0 000 .14V19h-3v-9h2.9v1.3a3.11 3.11 0 012.7-1.4c1.55 0 3.36.86 3.36 3.66z"/></svg>
            </a>
            <a href="message" aria-label="Anonymous Message">
                <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z"/></svg>
            </a>
        </div>
    </div>

    <button class="theme-toggle" aria-label="Toggle theme" onclick="toggleTheme()">
        <svg class="theme-icon moon-icon" width="24" height="24" viewBox="0 0 24 24" fill="currentColor"><path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"/></svg>
        <svg class="theme-icon sun-icon hidden" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg>
    </button>

    <div class="stage-container remove">
        <div class="canvas-container">
            <canvas id="trails-canvas"></canvas>
            <canvas id="main-canvas"></canvas>
        </div>
    </div>

    <script>
        const MyMath = {
            random: (min, max) => Math.random() * (max - min) + min,
            randomInt: (min, max) => Math.floor(Math.random() * (max - min + 1)) + min,
            randomChoice: (arr) => arr[Math.floor(Math.random() * arr.length)],
            clamp: (val, min, max) => Math.min(Math.max(val, min), max),
            pointDist: (x1, y1, x2, y2) => Math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2),
            pointAngle: (x1, y1, x2, y2) => Math.atan2(y2 - y1, x2 - x1)
        };

        const fscreen = {
            fullscreenEnabled: document.fullscreenEnabled,
            fullscreenElement: document.fullscreenElement,
            requestFullscreen: (element) => element.requestFullscreen(),
            exitFullscreen: () => document.exitFullscreen(),
            addEventListener: (type, handler) => document.addEventListener(type, handler),
            removeEventListener: (type, handler) => document.removeEventListener(type, handler)
        };

        class Stage {
            constructor(id) {
                this.canvas = document.getElementById(id);
                this.ctx = this.canvas.getContext('2d');
                this.width = 0;
                this.height = 0;
                this.dpr = window.devicePixelRatio || 1;
                this.listeners = {};
            }
            resize(w, h) {
                this.width = w;
                this.height = h;
                this.canvas.width = w * this.dpr;
                this.canvas.height = h * this.dpr;
                this.canvas.style.width = w + 'px';
                this.canvas.style.height = h + 'px';
                this.ctx.scale(this.dpr, this.dpr);
            }
            addEventListener(type, handler) {
            }
        }

        const audioContext = new (window.AudioContext || window.webkitAudioContext)();
        function playTone(frequency, duration) {
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);
            oscillator.frequency.value = frequency;
            oscillator.type = 'sine';
            gainNode.gain.setValueAtTime(0.1, audioContext.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + duration);
            oscillator.start(audioContext.currentTime);
            oscillator.stop(audioContext.currentTime + duration);
        }

        function checkSpecialDate() {
            if (sessionStorage.getItem('specialEventPlayed')) return;

            const today = new Date();
            const month = today.getMonth() + 1;
            const day = today.getDate();
            let animationTriggered = false;

            if (month === 1 && day === 1) {
                initFireworks();
                animationTriggered = true;
            } else if (month === 4 && day === 5) {
                showConfetti();
                animationTriggered = true;
            } else if (month === 12 && day === 25) {
                showSnow();
                animationTriggered = true;
            }

            if (animationTriggered) {
                sessionStorage.setItem('specialEventPlayed', 'true');
            }
        }

        function toggleTheme() {
            const html = document.documentElement;
            const body = document.body;
            const sunIcon = document.querySelector('.sun-icon');
            const moonIcon = document.querySelector('.moon-icon');
            html.classList.toggle('dark-mode');
            body.classList.toggle('dark-mode');
            sunIcon.classList.toggle('hidden');
            moonIcon.classList.toggle('hidden');
            const isDark = body.classList.contains('dark-mode');
            localStorage.setItem('theme', isDark ? 'dark' : 'light');
            if (isDark) { playTone(800, 0.1); } else { playTone(400, 0.15); }
        }

        window.addEventListener('DOMContentLoaded', () => {
            const savedTheme = localStorage.getItem('theme');
            if (savedTheme === 'dark') {
                document.documentElement.classList.add('dark-mode');
                document.body.classList.add('dark-mode');
                document.querySelector('.sun-icon').classList.remove('hidden');
                document.querySelector('.moon-icon').classList.add('hidden');
            }
            setTimeout(() => checkSpecialDate(), 600);
        });

        function showConfetti() {
             const canvas = document.createElement('canvas');
            canvas.style.cssText = 'position:fixed;top:0;left:0;width:100%;height:100%;pointer-events:none;z-index:9999;background:transparent;';
            document.body.appendChild(canvas);
            const ctx = canvas.getContext('2d');
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            const confetti = [];
            const colors = ['#f44336', '#e91e63', '#9c27b0', '#673ab7', '#3f51b5', '#2196f3', '#03a9f4', '#00bcd4', '#009688', '#4CAF50', '#8BC34A', '#CDDC39', '#FFEB3B', '#FFC107', '#FF9800', '#FF5722'];
            class Confetto {
                constructor() {
                    this.x = Math.random() * canvas.width;
                    this.y = Math.random() * canvas.height - canvas.height;
                    this.color = colors[Math.floor(Math.random() * colors.length)];
                    this.size = Math.random() * 10 + 10; 
                    this.height = Math.random() * 4 + 6; 
                    this.speed = Math.random() * 3 + 2;
                    this.angle = Math.random() * 360;
                    this.tilt = Math.random() * 10;
                    this.tiltAngleIncremental = Math.random() * 0.07 + 0.05;
                    this.tiltAngle = 0;
                }
                update() {
                    this.tiltAngle += this.tiltAngleIncremental;
                    this.y += (Math.cos(this.tiltAngle) + 3 + this.speed) / 2;
                    this.x += Math.sin(this.tiltAngle) * 2;
                    this.tilt = Math.sin(this.tiltAngle) * 15;
                    return this.y < canvas.height;
                }
                draw() {
                    ctx.save();
                    ctx.fillStyle = this.color;
                    ctx.translate(this.x, this.y);
                    ctx.rotate(this.angle);
                    ctx.fillRect(-this.size / 2, -this.height / 2, this.size, this.height + this.tilt);
                    ctx.restore();
                }
            }
            let frameCount = 0;
            function animate() {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                if (frameCount < 150) for (let i = 0; i < 5; i++) confetti.push(new Confetto());
                for (let i = confetti.length - 1; i >= 0; i--) {
                    confetti[i].draw();
                    if (!confetti[i].update()) confetti.splice(i, 1);
                }
                frameCount++;
                if (frameCount < 500 || confetti.length > 0) requestAnimationFrame(animate);
                else { canvas.style.transition = 'opacity 1s'; canvas.style.opacity = '0'; setTimeout(() => canvas.remove(), 1000); }
            }
            animate();
        }

        function showSnow() {
            const canvas = document.createElement('canvas');
            canvas.style.cssText = 'position:fixed;top:0;left:0;width:100%;height:100%;pointer-events:none;z-index:9999;background:transparent;';
            document.body.appendChild(canvas);
            const ctx = canvas.getContext('2d');
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            const particles = [];
            class Snowflake {
                constructor() {
                    this.x = Math.random() * canvas.width;
                    this.y = -20;
                    this.size = Math.random() * 8 + 5;
                    this.speedY = Math.random() * 1 + 0.5;
                    this.speedX = Math.random() * 0.5 - 0.25;
                    this.opacity = Math.random() * 0.5 + 0.3;
                    this.angle = Math.random() * Math.PI * 2;
                    this.spinSpeed = (Math.random() - 0.5) * 0.02;
                }
                update() {
                    this.y += this.speedY;
                    this.x += this.speedX + Math.sin(this.y * 0.01) * 0.5;
                    this.angle += this.spinSpeed;
                    return this.y < canvas.height + 20;
                }
                draw() {
                    ctx.save();
                    ctx.globalAlpha = this.opacity;
                    ctx.strokeStyle = 'white';
                    ctx.lineWidth = 1.5;
                    ctx.translate(this.x, this.y);
                    ctx.rotate(this.angle);
                    for (let i = 0; i < 6; i++) {
                        ctx.beginPath();
                        ctx.moveTo(0, 0); ctx.lineTo(0, -this.size);
                        ctx.moveTo(0, -this.size * 0.6); ctx.lineTo(this.size * 0.3, -this.size * 0.8);
                        ctx.moveTo(0, -this.size * 0.6); ctx.lineTo(-this.size * 0.3, -this.size * 0.8);
                        ctx.stroke(); ctx.rotate(Math.PI / 3);
                    }
                    ctx.restore();
                }
            }
            let frameCount = 0;
            function animate() {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                if (frameCount < 400 && frameCount % 5 === 0) particles.push(new Snowflake());
                for (let i = particles.length - 1; i >= 0; i--) {
                    particles[i].draw();
                    if (!particles[i].update()) particles.splice(i, 1);
                }
                frameCount++;
                if (frameCount < 600 || particles.length > 0) requestAnimationFrame(animate);
                else { canvas.style.transition = 'opacity 2s'; canvas.style.opacity = '0'; setTimeout(() => canvas.remove(), 2000); }
            }
            animate();
        }

        function initFireworks() {
            "use strict";
            
            document.querySelector('.stage-container').classList.remove('remove');

            const IS_MOBILE = window.innerWidth <= 640;
            const IS_DESKTOP = window.innerWidth > 800;
            const IS_HEADER = IS_DESKTOP && window.innerHeight < 300;
            const IS_HIGH_END_DEVICE = (() => {
                const hwConcurrency = navigator.hardwareConcurrency;
                if (!hwConcurrency) return false;
                const minCount = window.innerWidth <= 1024 ? 4 : 8;
                return hwConcurrency >= minCount;
            })();
            const MAX_WIDTH = 7680;
            const MAX_HEIGHT = 4320;
            const GRAVITY = 0.9; 
            let simSpeed = 1;

            function getDefaultScaleFactor() {
                if (IS_MOBILE) return 0.9;
                if (IS_HEADER) return 0.75;
                return 1;
            }

            let stageW, stageH;
            let quality = 1;
            let isLowQuality = false;
            let isNormalQuality = true;
            let isHighQuality = false;

            const QUALITY_LOW = 1;
            const QUALITY_NORMAL = 2;
            const QUALITY_HIGH = 3;
            const SKY_LIGHT_NONE = 0;
            const SKY_LIGHT_DIM = 1;
            const SKY_LIGHT_NORMAL = 2;

            const COLOR = {
                Red: "#ff0043",
                Green: "#14fc56",
                Blue: "#1e7fff",
                Purple: "#e60aff",
                Gold: "#ffbf36",
                White: "#ffffff",
            };

            const INVISIBLE = "_INVISIBLE_";
            const PI_2 = Math.PI * 2;
            const PI_HALF = Math.PI * 0.5;

            const trailsStage = new Stage("trails-canvas");
            const mainStage = new Stage("main-canvas");
            const stages = [trailsStage, mainStage];

            const store = {
                state: {
                    paused: false,
                    soundEnabled: false,
                    menuOpen: false,
                    openHelpTopic: null,
                    fullscreen: false,
                    config: {
                        quality: String(IS_HIGH_END_DEVICE ? QUALITY_HIGH : QUALITY_NORMAL),
                        shell: "Random",
                        size: IS_DESKTOP ? "3" : IS_HEADER ? "1.2" : "2",
                        autoLaunch: true,
                        finale: false,
                        skyLighting: SKY_LIGHT_NORMAL + "",
                        hideControls: IS_HEADER,
                        longExposure: false,
                        scaleFactor: getDefaultScaleFactor(),
                    },
                },
                setState(nextState) {
                    this.state = Object.assign({}, this.state, nextState);
                },
                subscribe(listener) {}
            };

            function configDidUpdate() {
                const config = store.state.config;
                quality = +config.quality;
                isLowQuality = quality === QUALITY_LOW;
                isNormalQuality = quality === QUALITY_NORMAL;
                isHighQuality = quality === QUALITY_HIGH;
                Spark.drawWidth = quality === QUALITY_HIGH ? 0.75 : 1;
            }

            const soundEnabledSelector = () => store.state.soundEnabled;
            const canPlaySoundSelector = () => !store.state.paused && store.state.soundEnabled;
            const shellNameSelector = () => store.state.config.shell;
            const shellSizeSelector = () => +store.state.config.size;
            const finaleSelector = () => store.state.config.finale;
            const skyLightingSelector = () => +store.state.config.skyLighting;
            const scaleFactorSelector = () => store.state.config.scaleFactor;

            const COLOR_NAMES = Object.keys(COLOR);
            const COLOR_CODES = COLOR_NAMES.map((colorName) => COLOR[colorName]);
            const COLOR_CODES_W_INVIS = [...COLOR_CODES, INVISIBLE];
            const COLOR_TUPLES = {};
            COLOR_CODES.forEach((hex) => {
                COLOR_TUPLES[hex] = {
                    r: parseInt(hex.substr(1, 2), 16),
                    g: parseInt(hex.substr(3, 2), 16),
                    b: parseInt(hex.substr(5, 2), 16),
                };
            });

            function randomColorSimple() { return COLOR_CODES[(Math.random() * COLOR_CODES.length) | 0]; }

            let lastColor;
            function randomColor(options) {
                const notSame = options && options.notSame;
                const notColor = options && options.notColor;
                const limitWhite = options && options.limitWhite;
                let color = randomColorSimple();
                if (limitWhite && color === COLOR.White && Math.random() < 0.6) {
                    color = randomColorSimple();
                }
                if (notSame) { while (color === lastColor) { color = randomColorSimple(); } } 
                else if (notColor) { while (color === notColor) { color = randomColorSimple(); } }
                lastColor = color;
                return color;
            }

            function whiteOrGold() { return Math.random() < 0.5 ? COLOR.Gold : COLOR.White; }
            function makePistilColor(shellColor) {
                return shellColor === COLOR.White || shellColor === COLOR.Gold ? randomColor({ notColor: shellColor }) : whiteOrGold();
            }

            function createParticleArc(start, arcLength, count, randomness, particleFactory) {
                const angleDelta = arcLength / count;
                const end = start + arcLength - angleDelta * 0.5;
                if (end > start) for (let angle = start; angle < end; angle += angleDelta) particleFactory(angle + Math.random() * angleDelta * randomness);
                else for (let angle = start; angle > end; angle += angleDelta) particleFactory(angle + Math.random() * angleDelta * randomness);
            }
            function createBurst(count, particleFactory, startAngle = 0, arcLength = PI_2) {
                const R = 0.5 * Math.sqrt(count / Math.PI);
                const C = 2 * R * Math.PI;
                const C_HALF = C / 2;
                for (let i = 0; i <= C_HALF; i++) {
                    const ringAngle = (i / C_HALF) * PI_HALF;
                    const ringSize = Math.cos(ringAngle);
                    const partsPerFullRing = C * ringSize;
                    const partsPerArc = partsPerFullRing * (arcLength / PI_2);
                    const angleInc = PI_2 / partsPerFullRing;
                    const angleOffset = Math.random() * angleInc + startAngle;
                    const maxRandomAngleOffset = angleInc * 0.33;
                    for (let i = 0; i < partsPerArc; i++) {
                        const randomAngleOffset = Math.random() * maxRandomAngleOffset;
                        let angle = angleInc * i + angleOffset + randomAngleOffset;
                        particleFactory(angle, ringSize);
                    }
                }
            }

            const BurstFlash = { active: [], _pool: [], _new() { return {}; }, add(x, y, radius) { const instance = this._pool.pop() || this._new(); instance.x = x; instance.y = y; instance.radius = radius; this.active.push(instance); return instance; }, returnInstance(instance) { this._pool.push(instance); } };
            function createParticleCollection() { const collection = {}; COLOR_CODES_W_INVIS.forEach((color) => { collection[color] = []; }); return collection; }
            
            const Star = {
                drawWidth: 3, airDrag: 0.98, airDragHeavy: 0.992, active: createParticleCollection(), _pool: [], _new() { return {}; },
                add(x, y, color, angle, speed, life, speedOffX, speedOffY) {
                    const instance = this._pool.pop() || this._new();
                    instance.visible = true; instance.heavy = false; instance.x = x; instance.y = y; instance.prevX = x; instance.prevY = y; instance.color = color; instance.speedX = Math.sin(angle) * speed + (speedOffX || 0); instance.speedY = Math.cos(angle) * speed + (speedOffY || 0); instance.life = life; instance.fullLife = life; instance.spinAngle = Math.random() * PI_2; instance.spinSpeed = 0.8; instance.spinRadius = 0; instance.sparkFreq = 0; instance.sparkSpeed = 1; instance.sparkTimer = 0; instance.sparkColor = color; instance.sparkLife = 750; instance.sparkLifeVariation = 0.25; instance.strobe = false;
                    this.active[color].push(instance); return instance;
                },
                returnInstance(instance) { instance.onDeath && instance.onDeath(instance); instance.onDeath = null; instance.secondColor = null; instance.transitionTime = 0; instance.colorChanged = false; this._pool.push(instance); }
            };
            const Spark = {
                drawWidth: 0, airDrag: 0.9, active: createParticleCollection(), _pool: [], _new() { return {}; },
                add(x, y, color, angle, speed, life) { const instance = this._pool.pop() || this._new(); instance.x = x; instance.y = y; instance.prevX = x; instance.prevY = y; instance.color = color; instance.speedX = Math.sin(angle) * speed; instance.speedY = Math.cos(angle) * speed; instance.life = life; this.active[color].push(instance); return instance; },
                returnInstance(instance) { this._pool.push(instance); }
            };

            function crossetteEffect(star) { createParticleArc(Math.random() * PI_HALF, PI_2, 4, 0.5, (angle) => { Star.add(star.x, star.y, star.color, angle, Math.random() * 0.6 + 0.75, 600); }); }
            function floralEffect(star) { createBurst(12 + 6 * quality, (angle, speedMult) => { Star.add(star.x, star.y, star.color, angle, speedMult * 2.4, 1000 + Math.random() * 300, star.speedX, star.speedY); }); BurstFlash.add(star.x, star.y, 46); }
            function fallingLeavesEffect(star) { createBurst(7, (angle, speedMult) => { const newStar = Star.add(star.x, star.y, INVISIBLE, angle, speedMult * 2.4, 2400 + Math.random() * 600, star.speedX, star.speedY); newStar.sparkColor = COLOR.Gold; newStar.sparkFreq = 144 / quality; newStar.sparkSpeed = 0.28; newStar.sparkLife = 750; newStar.sparkLifeVariation = 3.2; }); BurstFlash.add(star.x, star.y, 46); }
            function crackleEffect(star) { createParticleArc(0, PI_2, isHighQuality ? 32 : 16, 1.8, (angle) => { Spark.add(star.x, star.y, COLOR.Gold, angle, Math.pow(Math.random(), 0.45) * 2.4, 300 + Math.random() * 200); }); }

            class Shell {
                constructor(options) {
                    Object.assign(this, options);
                    this.starLifeVariation = options.starLifeVariation || 0.125;
                    this.color = options.color || randomColor();
                    this.glitterColor = options.glitterColor || this.color;
                    if (!this.starCount) { const density = options.starDensity || 1; const scaledSize = this.spreadSize / 54; this.starCount = Math.max(6, scaledSize * scaledSize * density); }
                }
                launch(position, launchHeight) {
                    const width = stageW; const height = stageH; const hpad = 60; const vpad = 50; const minHeightPercent = 0.45; const minHeight = height - height * minHeightPercent; const launchX = position * (width - hpad * 2) + hpad; const launchY = height; const burstY = minHeight - launchHeight * (minHeight - vpad); const launchDistance = launchY - burstY; const launchVelocity = Math.pow(launchDistance * 0.04, 0.64);
                    const comet = (this.comet = Star.add(launchX, launchY, typeof this.color === "string" && this.color !== "random" ? this.color : COLOR.White, Math.PI, launchVelocity * (this.horsetail ? 1.2 : 1), launchVelocity * (this.horsetail ? 100 : 400)));
                    comet.heavy = true; comet.spinRadius = MyMath.random(0.32, 0.85); comet.sparkFreq = 32 / quality; if (isHighQuality) comet.sparkFreq = 8; comet.sparkLife = 320; comet.sparkLifeVariation = 3; if (this.glitter === "willow" || this.fallingLeaves) { comet.sparkFreq = 20 / quality; comet.sparkSpeed = 0.5; comet.sparkLife = 500; } if (this.color === INVISIBLE) { comet.sparkColor = COLOR.Gold; }
                    if (Math.random() > 0.4 && !this.horsetail) { comet.secondColor = INVISIBLE; comet.transitionTime = Math.pow(Math.random(), 1.5) * 700 + 500; }
                    comet.onDeath = (comet) => this.burst(comet.x, comet.y);
                }
                burst(x, y) {
                    const speed = this.spreadSize / 96; let color, onDeath, sparkFreq, sparkSpeed, sparkLife; let sparkLifeVariation = 0.25;
                    if (this.crossette) onDeath = (star) => { crossetteEffect(star); };
                    if (this.crackle) onDeath = (star) => { crackleEffect(star); };
                    if (this.floral) onDeath = floralEffect;
                    if (this.fallingLeaves) onDeath = fallingLeavesEffect;
                    if (this.glitter === "light") { sparkFreq = 400; sparkSpeed = 0.3; sparkLife = 300; sparkLifeVariation = 2; }
                    else if (this.glitter === "medium") { sparkFreq = 200; sparkSpeed = 0.44; sparkLife = 700; sparkLifeVariation = 2; }
                    else if (this.glitter === "heavy") { sparkFreq = 80; sparkSpeed = 0.8; sparkLife = 1400; sparkLifeVariation = 2; }
                    else if (this.glitter === "thick") { sparkFreq = 16; sparkSpeed = isHighQuality ? 1.65 : 1.5; sparkLife = 1400; sparkLifeVariation = 3; }
                    else if (this.glitter === "streamer") { sparkFreq = 32; sparkSpeed = 1.05; sparkLife = 620; sparkLifeVariation = 2; }
                    else if (this.glitter === "willow") { sparkFreq = 120; sparkSpeed = 0.34; sparkLife = 1400; sparkLifeVariation = 3.8; }
                    sparkFreq = sparkFreq / quality;
                    let firstStar = true;
                    const starFactory = (angle, speedMult) => {
                        const standardInitialSpeed = this.spreadSize / 1800;
                        const star = Star.add(x, y, color || randomColor(), angle, speedMult * speed, this.starLife + Math.random() * this.starLife * this.starLifeVariation, this.horsetail ? this.comet && this.comet.speedX : 0, this.horsetail ? this.comet && this.comet.speedY : -standardInitialSpeed);
                        if (this.secondColor) { star.transitionTime = this.starLife * (Math.random() * 0.05 + 0.32); star.secondColor = this.secondColor; }
                        if (this.strobe) { star.transitionTime = this.starLife * (Math.random() * 0.08 + 0.46); star.strobe = true; star.strobeFreq = Math.random() * 20 + 40; if (this.strobeColor) star.secondColor = this.strobeColor; }
                        star.onDeath = onDeath;
                        if (this.glitter) { star.sparkFreq = sparkFreq; star.sparkSpeed = sparkSpeed; star.sparkLife = sparkLife; star.sparkLifeVariation = sparkLifeVariation; star.sparkColor = this.glitterColor; star.sparkTimer = Math.random() * star.sparkFreq; }
                    };
                    if (typeof this.color === "string") {
                        if (this.color === "random") color = null; else color = this.color;
                        if (this.ring) {
                            const ringStartAngle = Math.random() * Math.PI; const ringSquash = Math.pow(Math.random(), 2) * 0.85 + 0.15;
                            createParticleArc(0, PI_2, this.starCount, 0, (angle) => {
                                const initSpeedX = Math.sin(angle) * speed * ringSquash; const initSpeedY = Math.cos(angle) * speed;
                                const newSpeed = MyMath.pointDist(0, 0, initSpeedX, initSpeedY); const newAngle = MyMath.pointAngle(0, 0, initSpeedX, initSpeedY) + ringStartAngle;
                                const star = Star.add(x, y, color, newAngle, newSpeed, this.starLife + Math.random() * this.starLife * this.starLifeVariation);
                                if (this.glitter) { star.sparkFreq = sparkFreq; star.sparkSpeed = sparkSpeed; star.sparkLife = sparkLife; star.sparkLifeVariation = sparkLifeVariation; star.sparkColor = this.glitterColor; star.sparkTimer = Math.random() * star.sparkFreq; }
                            });
                        } else createBurst(this.starCount, starFactory);
                    } else if (Array.isArray(this.color)) {
                        if (Math.random() < 0.5) { const start = Math.random() * Math.PI; const start2 = start + Math.PI; const arc = Math.PI; color = this.color[0]; createBurst(this.starCount, starFactory, start, arc); color = this.color[1]; createBurst(this.starCount, starFactory, start2, arc); } 
                        else { color = this.color[0]; createBurst(this.starCount / 2, starFactory); color = this.color[1]; createBurst(this.starCount / 2, starFactory); }
                    }
                    if (this.pistil) { const innerShell = new Shell({ spreadSize: this.spreadSize * 0.5, starLife: this.starLife * 0.6, starLifeVariation: this.starLifeVariation, starDensity: 1.4, color: this.pistilColor, glitter: "light", glitterColor: this.pistilColor === COLOR.Gold ? COLOR.Gold : COLOR.White }); innerShell.burst(x, y); }
                    if (this.streamers) { const innerShell = new Shell({ spreadSize: this.spreadSize * 0.9, starLife: this.starLife * 0.8, starLifeVariation: this.starLifeVariation, starCount: Math.floor(Math.max(6, this.spreadSize / 45)), color: COLOR.White, glitter: "streamer" }); innerShell.burst(x, y); }
                    BurstFlash.add(x, y, this.spreadSize / 4);
                }
            }

            const crysanthemumShell = (size = 1) => {
                const glitter = Math.random() < 0.25;
                const singleColor = Math.random() < 0.72;
                const color = singleColor ? randomColor({ limitWhite: true }) : [randomColor(), randomColor({ notSame: true })];
                const pistil = singleColor && Math.random() < 0.42;
                const pistilColor = pistil && makePistilColor(color);
                const secondColor = singleColor && (Math.random() < 0.2 || color === COLOR.White) ? pistilColor || randomColor({ notColor: color, limitWhite: true }) : null;
                const streamers = !pistil && color !== COLOR.White && Math.random() < 0.42;
                let starDensity = glitter ? 1.1 : 1.25;
                if (isLowQuality) starDensity *= 0.8;
                if (isHighQuality) starDensity = 1.2;
                return { shellSize: size, spreadSize: 300 + size * 100, starLife: 900 + size * 200, starDensity, color, secondColor, glitter: glitter ? "light" : "", glitterColor: whiteOrGold(), pistil, pistilColor, streamers };
            };
            const ghostShell = (size = 1) => {
                const shell = crysanthemumShell(size);
                shell.starLife *= 1.5;
                let ghostColor = randomColor({ notColor: COLOR.White });
                shell.streamers = true;
                const pistil = Math.random() < 0.42;
                const pistilColor = pistil && makePistilColor(ghostColor);
                shell.color = INVISIBLE;
                shell.secondColor = ghostColor;
                shell.glitter = "";
                return shell;
            };
            const strobeShell = (size = 1) => {
                const color = randomColor({ limitWhite: true });
                return { shellSize: size, spreadSize: 280 + size * 92, starLife: 1100 + size * 200, starLifeVariation: 0.4, starDensity: 1.1, color, glitter: "light", glitterColor: COLOR.White, strobe: true, strobeColor: Math.random() < 0.5 ? COLOR.White : null, pistil: Math.random() < 0.5, pistilColor: makePistilColor(color) };
            };
            const palmShell = (size = 1) => {
                const color = randomColor();
                const thick = Math.random() < 0.5;
                return { shellSize: size, color, spreadSize: 250 + size * 75, starDensity: thick ? 0.15 : 0.4, starLife: 1800 + size * 200, glitter: thick ? "thick" : "heavy" };
            };
            const ringShell = (size = 1) => {
                const color = randomColor();
                const pistil = Math.random() < 0.75;
                return { shellSize: size, ring: true, color, spreadSize: 300 + size * 100, starLife: 900 + size * 200, starCount: 2.2 * PI_2 * (size + 1), pistil, pistilColor: makePistilColor(color), glitter: !pistil ? "light" : "", glitterColor: color === COLOR.Gold ? COLOR.Gold : COLOR.White, streamers: Math.random() < 0.3 };
            };
            const crossetteShell = (size = 1) => {
                const color = randomColor({ limitWhite: true });
                return { shellSize: size, spreadSize: 300 + size * 100, starLife: 750 + size * 160, starLifeVariation: 0.4, starDensity: 0.85, color, crossette: true, pistil: Math.random() < 0.5, pistilColor: makePistilColor(color) };
            };
            const floralShell = (size = 1) => ({ shellSize: size, spreadSize: 300 + size * 120, starDensity: 0.12, starLife: 500 + size * 50, starLifeVariation: 0.5, color: Math.random() < 0.65 ? "random" : Math.random() < 0.15 ? randomColor() : [randomColor(), randomColor({ notSame: true })], floral: true });
            const fallingLeavesShell = (size = 1) => ({ shellSize: size, color: INVISIBLE, spreadSize: 300 + size * 120, starDensity: 0.12, starLife: 500 + size * 50, starLifeVariation: 0.5, glitter: "medium", glitterColor: COLOR.Gold, fallingLeaves: true });
            const willowShell = (size = 1) => ({ shellSize: size, spreadSize: 300 + size * 100, starDensity: 0.6, starLife: 3000 + size * 300, glitter: "willow", glitterColor: COLOR.Gold, color: INVISIBLE });
            const crackleShell = (size = 1) => {
                const color = Math.random() < 0.75 ? COLOR.Gold : randomColor();
                return { shellSize: size, spreadSize: 380 + size * 75, starDensity: isLowQuality ? 0.65 : 1, starLife: 600 + size * 100, starLifeVariation: 0.32, glitter: "light", glitterColor: COLOR.Gold, color, crackle: true, pistil: Math.random() < 0.65, pistilColor: makePistilColor(color) };
            };
            const horsetailShell = (size = 1) => {
                const color = randomColor();
                return { shellSize: size, horsetail: true, color, spreadSize: 250 + size * 38, starDensity: 0.9, starLife: 2500 + size * 300, glitter: "medium", glitterColor: Math.random() < 0.5 ? whiteOrGold() : color, strobe: color === COLOR.White };
            };

            function randomShellName() { return Math.random() < 0.5 ? "Crysanthemum" : shellNames[(Math.random() * (shellNames.length - 1) + 1) | 0]; }
            function randomShell(size) { if (IS_HEADER) return randomFastShell()(size); return shellTypes[randomShellName()](size); }
            function shellFromConfig(size) { return shellTypes[shellNameSelector()](size); }
            
            const fastShellBlacklist = ["Falling Leaves", "Floral", "Willow"];
            function randomFastShell() {
                const isRandom = shellNameSelector() === "Random";
                let shellName = isRandom ? randomShellName() : shellNameSelector();
                if (isRandom) { while (fastShellBlacklist.includes(shellName)) { shellName = randomShellName(); } }
                return shellTypes[shellName];
            }

            const shellTypes = { Random: randomShell, Crackle: crackleShell, Crossette: crossetteShell, Crysanthemum: crysanthemumShell, "Falling Leaves": fallingLeavesShell, Floral: floralShell, Ghost: ghostShell, "Horse Tail": horsetailShell, Palm: palmShell, Ring: ringShell, Strobe: strobeShell, Willow: willowShell };
            const shellNames = Object.keys(shellTypes);

            function fitShellPositionInBoundsH(position) { const edge = 0.18; return (1 - edge * 2) * position + edge; }
            function fitShellPositionInBoundsV(position) { return position * 0.75; }
            function getRandomShellPositionH() { return fitShellPositionInBoundsH(Math.random()); }
            function getRandomShellPositionV() { return fitShellPositionInBoundsV(Math.random()); }
            function getRandomShellSize() {
                const baseSize = shellSizeSelector();
                const maxVariance = Math.min(2.5, baseSize);
                const variance = Math.random() * maxVariance;
                const size = baseSize - variance;
                const height = maxVariance === 0 ? Math.random() : 1 - variance / maxVariance;
                const centerOffset = Math.random() * (1 - height * 0.65) * 0.5;
                const x = Math.random() < 0.5 ? 0.5 - centerOffset : 0.5 + centerOffset;
                return { size, x: fitShellPositionInBoundsH(x), height: fitShellPositionInBoundsV(height) };
            }

            function launchShellFromConfig(event) {
                const shell = new Shell(shellFromConfig(shellSizeSelector()));
                const w = mainStage.width;
                const h = mainStage.height;
                shell.launch(event ? event.x / w : getRandomShellPositionH(), event ? 1 - event.y / h : getRandomShellPositionV());
            }

            function seqRandomShell() {
                const size = getRandomShellSize();
                const shell = new Shell(shellFromConfig(size.size));
                shell.launch(size.x, size.height);
                let extraDelay = shell.starLife;
                if (shell.fallingLeaves) extraDelay = 4600;
                return 900 + Math.random() * 600 + extraDelay;
            }
            function seqTwoRandom() {
                const size1 = getRandomShellSize();
                const size2 = getRandomShellSize();
                const shell1 = new Shell(shellFromConfig(size1.size));
                const shell2 = new Shell(shellFromConfig(size2.size));
                const leftOffset = Math.random() * 0.2 - 0.1;
                const rightOffset = Math.random() * 0.2 - 0.1;
                shell1.launch(0.3 + leftOffset, size1.height);
                setTimeout(() => shell2.launch(0.7 + rightOffset, size2.height), 100);
                let extraDelay = Math.max(shell1.starLife, shell2.starLife);
                if (shell1.fallingLeaves || shell2.fallingLeaves) extraDelay = 4600;
                return 900 + Math.random() * 600 + extraDelay;
            }
            function seqTriple() {
                const shellType = randomFastShell();
                const baseSize = shellSizeSelector();
                const smallSize = Math.max(0, baseSize - 1.25);
                const offset = Math.random() * 0.08 - 0.04;
                const shell1 = new Shell(shellType(baseSize));
                shell1.launch(0.5 + offset, 0.7);
                const leftDelay = 1000 + Math.random() * 400;
                const rightDelay = 1000 + Math.random() * 400;
                setTimeout(() => { const offset = Math.random() * 0.08 - 0.04; const shell2 = new Shell(shellType(smallSize)); shell2.launch(0.2 + offset, 0.1); }, leftDelay);
                setTimeout(() => { const offset = Math.random() * 0.08 - 0.04; const shell3 = new Shell(shellType(smallSize)); shell3.launch(0.8 + offset, 0.1); }, rightDelay);
                return 4000;
            }
            
            let isFirstSeq = true;
            function startSequence() {
                if (isFirstSeq) { isFirstSeq = false; if (IS_HEADER) return seqTwoRandom(); else { const shell = new Shell(crysanthemumShell(shellSizeSelector())); shell.launch(0.5, 0.5); return 2400; } }
                if (finaleSelector()) return 6000; 
                const rand = Math.random();
                if (rand < 0.6 && !IS_HEADER) return seqRandomShell();
                else if (rand < 0.8) return seqTwoRandom();
                else if (rand < 1) return seqTriple();
            }

            function handleResize() {
                const w = window.innerWidth;
                const h = window.innerHeight;
                const containerW = Math.min(w, MAX_WIDTH);
                const containerH = w <= 420 ? h : Math.min(h, MAX_HEIGHT);
                const stageContainer = document.querySelector('.stage-container');
                stageContainer.style.width = containerW + "px";
                stageContainer.style.height = containerH + "px";
                stages.forEach((stage) => stage.resize(containerW, containerH));
                const scaleFactor = scaleFactorSelector();
                stageW = containerW / scaleFactor;
                stageH = containerH / scaleFactor;
            }

            handleResize();
            window.addEventListener("resize", handleResize);

            let currentFrame = 0;
            let autoLaunchTime = 0;

            function update(frameTime, lag) {
                if (store.state.paused) return;

                const width = stageW;
                const height = stageH;
                const timeStep = frameTime * simSpeed;
                const speed = simSpeed * lag;

                currentFrame++;

                if (store.state.config.autoLaunch) {
                    autoLaunchTime -= timeStep;
                    if (autoLaunchTime <= 0) {
                        autoLaunchTime = startSequence() * 1.25;
                    }
                }

                const starDrag = 1 - (1 - Star.airDrag) * speed;
                const starDragHeavy = 1 - (1 - Star.airDragHeavy) * speed;
                const sparkDrag = 1 - (1 - Spark.airDrag) * speed;
                const gAcc = (timeStep / 1000) * GRAVITY;

                COLOR_CODES_W_INVIS.forEach((color) => {
                    const stars = Star.active[color];
                    for (let i = stars.length - 1; i >= 0; i--) {
                        const star = stars[i];
                        if (star.updateFrame === currentFrame) continue;
                        star.updateFrame = currentFrame;
                        star.life -= timeStep;
                        if (star.life <= 0) {
                            stars.splice(i, 1);
                            Star.returnInstance(star);
                        } else {
                            const burnRate = Math.pow(star.life / star.fullLife, 0.5);
                            const burnRateInverse = 1 - burnRate;
                            star.prevX = star.x; star.prevY = star.y;
                            star.x += star.speedX * speed; star.y += star.speedY * speed;
                            if (!star.heavy) { star.speedX *= starDrag; star.speedY *= starDrag; } else { star.speedX *= starDragHeavy; star.speedY *= starDragHeavy; }
                            star.speedY += gAcc;
                            if (star.sparkFreq) {
                                star.sparkTimer -= timeStep;
                                while (star.sparkTimer < 0) {
                                    star.sparkTimer += star.sparkFreq * 0.75 + star.sparkFreq * burnRateInverse * 4;
                                    Spark.add(star.x, star.y, star.sparkColor, Math.random() * PI_2, Math.random() * star.sparkSpeed * burnRate, star.sparkLife * 0.8 + Math.random() * star.sparkLifeVariation * star.sparkLife);
                                }
                            }
                            if (star.life < star.transitionTime && star.secondColor && !star.colorChanged) {
                                star.colorChanged = true;
                                star.color = star.secondColor;
                                stars.splice(i, 1);
                                Star.active[star.secondColor].push(star);
                                if (star.secondColor === INVISIBLE) star.sparkFreq = 0;
                            }
                        }
                    }
                    const sparks = Spark.active[color];
                    for (let i = sparks.length - 1; i >= 0; i--) {
                        const spark = sparks[i];
                        spark.life -= timeStep;
                        if (spark.life <= 0) { sparks.splice(i, 1); Spark.returnInstance(spark); } 
                        else {
                            spark.prevX = spark.x; spark.prevY = spark.y;
                            spark.x += spark.speedX * speed; spark.y += spark.speedY * speed;
                            spark.speedX *= sparkDrag; spark.speedY *= sparkDrag; spark.speedY += gAcc;
                        }
                    }
                });
                render(speed);
            }

            function render(speed) {
                const { dpr } = mainStage;
                const width = stageW;
                const height = stageH;
                const trailsCtx = trailsStage.ctx;
                const mainCtx = mainStage.ctx;

                const scaleFactor = scaleFactorSelector();
                trailsCtx.scale(dpr * scaleFactor, dpr * scaleFactor);
                mainCtx.scale(dpr * scaleFactor, dpr * scaleFactor);

                trailsCtx.globalCompositeOperation = "destination-out";
                trailsCtx.fillStyle = `rgba(0, 0, 0, ${store.state.config.longExposure ? 0.0025 : 0.175 * speed})`;
                trailsCtx.fillRect(0, 0, width, height);

                trailsCtx.globalCompositeOperation = "source-over"; 
                mainCtx.clearRect(0, 0, width, height);

                while (BurstFlash.active.length) {
                    const bf = BurstFlash.active.pop();
                    const burstGradient = trailsCtx.createRadialGradient(bf.x, bf.y, 0, bf.x, bf.y, bf.radius);
                    burstGradient.addColorStop(0.024, "rgba(255, 255, 255, 1)");
                    burstGradient.addColorStop(0.125, "rgba(255, 160, 20, 0.2)");
                    burstGradient.addColorStop(0.32, "rgba(255, 140, 20, 0.11)");
                    burstGradient.addColorStop(1, "rgba(255, 120, 20, 0)");
                    trailsCtx.fillStyle = burstGradient;
                    trailsCtx.fillRect(bf.x - bf.radius, bf.y - bf.radius, bf.radius * 2, bf.radius * 2);
                    BurstFlash.returnInstance(bf);
                }

                trailsCtx.globalCompositeOperation = "lighten";
                trailsCtx.lineWidth = Star.drawWidth;
                trailsCtx.lineCap = isLowQuality ? "square" : "round";
                mainCtx.strokeStyle = "#fff";
                mainCtx.lineWidth = 1;
                mainCtx.beginPath();
                
                COLOR_CODES.forEach((color) => {
                    const stars = Star.active[color];
                    trailsCtx.strokeStyle = color;
                    trailsCtx.beginPath();
                    stars.forEach((star) => {
                        if (star.visible) {
                            trailsCtx.moveTo(star.x, star.y);
                            trailsCtx.lineTo(star.prevX, star.prevY);
                            mainCtx.moveTo(star.x, star.y);
                            mainCtx.lineTo(star.x - star.speedX * 1.6, star.y - star.speedY * 1.6);
                        }
                    });
                    trailsCtx.stroke();
                });
                mainCtx.stroke();

                trailsCtx.lineWidth = Spark.drawWidth;
                trailsCtx.lineCap = "butt";
                COLOR_CODES.forEach((color) => {
                    const sparks = Spark.active[color];
                    trailsCtx.strokeStyle = color;
                    trailsCtx.beginPath();
                    sparks.forEach((spark) => {
                        trailsCtx.moveTo(spark.x, spark.y);
                        trailsCtx.lineTo(spark.prevX, spark.prevY);
                    });
                    trailsCtx.stroke();
                });

                trailsCtx.setTransform(1, 0, 0, 1, 0, 0);
                mainCtx.setTransform(1, 0, 0, 1, 0, 0);
            }

            configDidUpdate();
            
            let lastFrameTime = Date.now();
            function tick() {
                if (!store.state.paused) {
                    const now = Date.now();
                    const elapsed = now - lastFrameTime;
                    const timeStep = Math.min(elapsed, 100); 
                    const lag = timeStep / 16.666;
                    update(timeStep, lag);
                    lastFrameTime = now;
                }
                requestAnimationFrame(tick);
            }
            tick();
        }
    </script>
</body>
</html>
